PRODUCTION OPEN BETA: Implement Solana Swap that works for:
1) Normal tokens (graduated / DEX liquidity) via Jupiter
2) Pump.fun tokens on bonding curve via Pump trading path
Must be FAST, RELIABLE, non-custodial, and handle high traffic without user-facing errors.
Repo: Expo RN client (/client) + Express server (/server), single root package.json.
Do everything end-to-end in ONE pass. No questions.

NON-CUSTODIAL GUARANTEE
- Server NEVER stores mnemonics/private keys.
- Server NEVER signs transactions.
- Client signs (local keypair or WalletConnect).
- Server may build unsigned tx and broadcast signed tx.

PRIMARY INFRA
- Primary RPC: Helius (paid) via SOLANA_RPC_URL
- Fallback RPC: Triton via SOLANA_RPC_URL_FALLBACK
- Broadcast must try both + retries with jitter.
- Quotes/build must be cached/deduped to avoid 429.

========================================================
A) SERVER: Build a production swap engine with route selection
========================================================

Create /server/swap/ with:
- config.ts
- index.ts (router)
- jupiter.ts (quote + build)
- pump.ts (detect + build for bonding curve)
- route.ts (route decision engine)
- tokenlist.ts (cached token metadata)
- broadcast.ts (send signed tx fast)
- cache.ts (TTL cache + in-flight dedupe)
- README.md (how to test)

Mount in server/index.ts:
app.use("/api/swap", swapRouter);

ENV (document in README):
SOLANA_RPC_URL=<helius>
SOLANA_RPC_URL_FALLBACK=<triton>
JUPITER_BASE_URL=https://quote-api.jup.ag
JUPITER_QUOTE_PATH=/v6/quote
JUPITER_SWAP_PATH=/v6/swap
JUP_TIMEOUT_MS=8000
TOKENLIST_TTL_MS=21600000
SWAP_TOKENLIST_PRIMARY=https://token.jup.ag/strict
SWAP_TOKENLIST_FALLBACK=https://raw.githubusercontent.com/solana-labs/token-list/main/src/tokens/solana.tokenlist.json
PUMP_MODE_ENABLED=true
PUMPPORTAL_BASE_URL=https://pumpportal.fun
PUMPPORTAL_API_KEY=<optional>
RATE_LIMIT_QUOTES_PER_10S=25
RATE_LIMIT_BUILD_PER_10S=15

--------------------------------
A1) Server caching + in-flight dedupe (must)
--------------------------------
Implement cache.ts:
- TTLCache<K,V> (Map) with expiry
- InFlightDeduper<K,V> that stores Promise while in-flight
Use it for:
- route+quote
- token metadata lookup
- token list
- pump token detection

Hot cache TTLs:
- routeQuote TTL: 1500ms
- token metadata TTL: 10min
- pump detection TTL: 5min
- token list TTL: 6h

--------------------------------
A2) Token list + metadata (production)
--------------------------------
Implement tokenlist.ts:
- load cached list from disk/server cache
- fetch PRIMARY else FALLBACK
- normalize {mint,symbol,name,decimals,logoURI}
Endpoint:
GET /api/swap/solana/tokens?query=
- stable results even if upstream fails

Also endpoint for a single mint:
GET /api/swap/solana/token/:mint
- returns metadata (from list or on-chain fallback via RPC)
- cache 10 min

--------------------------------
A3) Jupiter integration (production)
--------------------------------
jupiter.ts:
GET /api/swap/solana/jup/quote?inputMint&outputMint&amount&slippageBps
- call Jupiter quote API with timeout + retries (3) + jitter
- on 429/5xx: if cached exists return cached; else return 503 UPSTREAM_BUSY

POST /api/swap/solana/jup/build
Body:
{ userPublicKey, quoteResponse, speedMode, slippageBps }
- map speedMode to priority fee cap + compute:
  standard: cap 200_000 lamports
  fast: cap 1_000_000
  turbo: cap 3_000_000
  hard max: 10_000_000
- call Jupiter swap API to get unsigned swapTransaction (base64)
- return base64 + lastValidBlockHeight + fee used

--------------------------------
A4) Pump.fun detection + trading path (production)
--------------------------------
pump.ts must support bonding curve trading in production.
We need 2 things:
1) Detect pump bonding curve vs graduated
2) Build unsigned buy/sell tx for bonding curve tokens

Implement detection:
- Only run detection when Jupiter says NO_ROUTE or when mint is suspected pump.
- Use PumpPortal or other reliable pump metadata endpoint:
  - Return fields: { isPump, isBondingCurve, isGraduated, marketProgram?, pool?, updatedAt }
- Cache 5 min.

Implement build endpoint:
POST /api/swap/solana/pump/build
Body:
{
  userPublicKey: string,
  mint: string,
  side: "buy"|"sell",
  amountSol?: number,
  amountTokens?: number,
  slippageBps: number,
  speedMode: "standard"|"fast"|"turbo"
}
Return:
{ ok:true, route:"PUMP", swapTransactionBase64: string }

This MUST return an UNSIGNED tx in base64 that user can sign.
Use PumpPortal “build local transaction” endpoint (or equivalent) and pass priority fee if supported.
If pump token is graduated: return ok:false code="GRADUATED_USE_JUPITER".

--------------------------------
A5) Route engine (single entrypoint)
--------------------------------
route.ts:
GET /api/swap/solana/route-quote
Query: inputMint, outputMint, amount, slippageBps
Flow:
1) Try Jupiter quote (cached/deduped).
2) If success => return {route:"JUPITER", quoteResponse}
3) If NO_ROUTE:
   - Detect Pump status for outputMint (if buying) or inputMint (if selling)
   - If isBondingCurve => return {route:"PUMP", pumpMeta}
   - Else return {route:"NONE", reason:"NO_LIQUIDITY_OR_UNROUTABLE"}
Return always structured:
{ ok:true|false, route, quoteResponse?, pumpMeta?, reason?, message? }

--------------------------------
A6) Broadcast signed tx FAST (Helius + Triton)
--------------------------------
broadcast.ts:
POST /api/swap/solana/send
Body: { signedTransactionBase64, mode:"standard"|"fast"|"turbo" }
- decode base64 -> bytes
- sendRawTransaction primary immediately
- for fast/turbo, also send to fallback after 250ms if no success yet
- retries with jitter
- return first success signature
- errors aggregated if all fail

Add GET /api/swap/solana/status?signature= to check confirmation.

--------------------------------
A7) Server rate-limit (don’t 429 users unnecessarily)
--------------------------------
Implement a lightweight limiter:
- per IP + optional wallet pubkey (if you pass)
- If exceeding, return cached routeQuote if available; only 429 if no cache exists.

========================================================
B) CLIENT: Production swap UX with automatic route execution
========================================================

1) Add API client: client/services/solanaSwapApi.ts
- routeQuote(params)
- jupBuild(body)
- pumpBuild(body)
- sendSignedTx(body)
- token search + token metadata endpoints

2) Swap screen logic:
When user sets pair+amount:
- call routeQuote (debounced 450ms; polling cadence based on speed selector)
- if route=JUPITER => show normal quote + route label “Jupiter”
- if route=PUMP => show route label “Pump (Bonding Curve)” and show buy/sell semantics:
  - If inputMint is SOL and output is pump => side=buy (amountSol)
  - If outputMint is SOL and input is pump => side=sell (amountTokens)
- if route=NONE => disable swap with reason.

On Swap press:
- If route=JUPITER:
  a) call jupBuild -> get unsigned tx base64
  b) run security preview context="swap"
  c) sign locally (internal or walletconnect)
  d) sendSignedTx -> signature -> success UI
- If route=PUMP:
  a) call pumpBuild -> unsigned tx base64
  b) security preview context="swap"
  c) sign locally
  d) sendSignedTx

3) Speed selector behavior:
- Standard/Fast/Turbo:
  - controls quote polling and fee caps already used in server build endpoints
  - show helper text: “Turbo uses higher priority fees (paid by you).”

4) Quotes refresh cadence (already discussed):
- Standard: 12s
- Fast: 6s
- Turbo: 2.5s
- Debounce typing: 500ms
- Pause when not focused/background
- Keep last quote visible; no flicker.

5) Token list reliability:
- load cached token list immediately from AsyncStorage
- refresh in background every 6h
- if list fails, keep cached silently
- allow manual mint paste -> fetch /api/swap/solana/token/:mint

========================================================
C) SECURITY DECODER: must not block our own swaps
========================================================
Update client/lib/solana/decoder.ts:
- accept userPubkey + context ("swap"|"dapp")
- If context="swap": only block when clear drainer pattern targets user (Assign user account, SetAuthority transferring to unrelated pubkey)
- Never block just because decode failed; warn only.
- Ensure Buffer/Hermes is not required; use Uint8Array-safe decode or import buffer polyfill early.

Ensure call sites pass context:
- Swap flow => context="swap"
- WalletConnect dapp signing => context="dapp"

========================================================
D) FINAL: RUN + VERIFY
========================================================
- Ensure TypeScript passes: npm run check:types
- Ensure swaps work in mainnet:
  1) SOL->USDC (Jupiter)
  2) SOL->Graduated pump token (Jupiter)
  3) SOL->Bonding curve pump token (Pump route)
- Provide list of files changed at end.

Implement now. No questions. Production quality only.