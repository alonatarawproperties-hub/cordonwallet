STEP 2: REPLACE FAKE WALLET CORE WITH REAL EVM WALLET + PERSISTENCE

Context from audit:
- Wallet creation uses fake seed phrases (not BIP39) and random addresses.
- We must replace this with REAL BIP39 mnemonic + REAL EVM address derivation.
- Persist securely (non-custodial). No secrets ever leave device.

GOAL:
After this step, Create/Import produces a real mnemonic + deterministic 0x address, saved securely, and survives app restarts.

A) Install + configure required libs (Expo-compatible)
1) Add these dependencies at the workspace where mobile and core can access them:
- viem
- @scure/bip39
- @scure/bip32
- @noble/hashes
- @noble/ciphers
- react-native-get-random-values
- react-native-url-polyfill
- expo-secure-store

2) Ensure crypto randomness works in Expo:
- In the mobile entry file (e.g. apps/mobile/App.tsx or apps/mobile/src/index.ts), add these imports at the VERY TOP:
  import "react-native-get-random-values";
  import "react-native-url-polyfill/auto";

This must run before any crypto/mnemonic generation.

B) Implement REAL wallet engine in /packages/core
Create /packages/core/src/wallet with:
- Types:
  WalletRecord = { id: string; name: string; address: `0x${string}`; createdAt: number; }
  StoredVault = { version: 1; wallets: WalletRecord[]; activeWalletId: string; encryptedPayload: string; }

- Functions (exported):
  createWallet({name?}) -> { mnemonic (12 words), wallet: WalletRecord }
  importWallet(mnemonic, {name?}) -> { wallet: WalletRecord }
  listWallets() -> WalletRecord[]
  getActiveWallet() -> WalletRecord | null
  setActiveWallet(id)
  lock()
  unlockWithPin(pin) -> boolean
  isUnlocked()

Wallet derivation:
- Use BIP39 12-word mnemonic (english wordlist)
- Derive EVM account using viem or scure derivation; output must be a valid 0x address.
- Import must validate mnemonic; reject invalid words/order.

C) Persistence + PIN protection (Expo SecureStore)
We need real persistence (non-demo).
Implement:
1) On first wallet creation/import:
- Require user to set a 6-digit PIN.
- Derive an encryption key from PIN using PBKDF2 (from @noble/hashes) with:
  - random salt (16 bytes)
  - sufficient iterations (e.g. 150k)
2) Encrypt sensitive payload (mnemonic(s) OR private key(s)) using AES-GCM (from @noble/ciphers):
- generate random iv (12 bytes)
- store salt + iv + ciphertext as base64 in SecureStore
3) Store non-sensitive wallet list + active wallet id in SecureStore too.

Important:
- Wallet address list is non-sensitive.
- Secret material must be encrypted at rest.
- NEVER send secrets to backend.

D) Replace placeholder UI wiring
Replace any screen/service that currently generates “fake seed/random address”.
- Create New Wallet button must:
  -> createWallet()
  -> show 12 words once
  -> require “I wrote it down”
  -> PIN setup
  -> save vault
  -> navigate into main app

- Import Existing Wallet must:
  -> accept mnemonic input
  -> validate
  -> PIN setup if first time
  -> save vault
  -> navigate into main app

E) QR code must become real
Replace QR placeholder with a real QR of the active wallet address.

F) README + verification checklist
Update README with:
- how to run Expo
- what files contain wallet engine
- how to test:
  1) create wallet -> record address
  2) kill app -> reopen -> unlock -> address must match
  3) import same mnemonic -> address must match

DONE WHEN:
- Create wallet shows a real 12-word mnemonic (BIP39)
- Derived address is deterministic and valid 0x...
- App restart retains wallet + requires unlock
- No fake seed/random address code remains anywhere
- QR shows the active address