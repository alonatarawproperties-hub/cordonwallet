REPLIT AGENT PROMPT (ONE-COPY)

Goal:
Upgrade Cordon’s Asset Detail -> About tab to show a TrustWallet-like “Contract Security” section:
- “Scanned by Cordon • just now” + Rescan button
- Detailed security rows (Safe / Warning / Not checked yet)
- Works for BOTH SPL Token Program and Token-2022 mints
- Implement real checks for:
  1) Token program (SPL vs Token-2022)
  2) Mintable (mintAuthority exists?)
  3) Freezable (freezeAuthority exists?)
  4) Token-2022 extensions (parse and list extensions)
  5) Metadata immutability (Metaplex metadata isMutable / updateAuthority)
- Replace “Unknown” wording with “Not checked yet” when we truly didn’t verify

Where:
- client/screens/AssetDetailScreen.tsx (single file)
- The About tab is renderAboutTab() around lines ~584-654 and rendered at ~740

Step 0 — Install deps (only if missing in package.json):
- @solana/spl-token
- @metaplex-foundation/mpl-token-metadata
Then run install for your package manager.

Step 1 — Add types in AssetDetailScreen.tsx (near existing interfaces):
Add:

type SecurityStatus = "safe" | "warning" | "not_checked";

type SecurityItem = {
  key: string;
  title: string;
  subtitle: string;
  status: SecurityStatus;
  statusLabel: string; // e.g. Safe / Warning / Not checked yet
};

type ContractSecurityResult = {
  items: SecurityItem[];
  scannedAtMs: number;
  scannedBy: "Cordon";
};

Step 2 — Add imports at top of AssetDetailScreen.tsx:
Add:

import AsyncStorage from "@react-native-async-storage/async-storage";
import { PublicKey } from "@solana/web3.js";

import {
  TOKEN_PROGRAM_ID,
  TOKEN_2022_PROGRAM_ID,
  getMint,
  getExtensionTypes,
} from "@solana/spl-token";

import {
  MPL_TOKEN_METADATA_PROGRAM_ID,
  findMetadataPda,
  Metadata,
} from "@metaplex-foundation/mpl-token-metadata";

NOTE: If MPL import differs in your setup, adjust to the correct exports available in your installed version.
If findMetadataPda isn’t available, derive PDA manually:
PDA seeds: ["metadata", MPL_TOKEN_METADATA_PROGRAM_ID, mint]

Step 3 — Add helper functions inside AssetDetailScreen.tsx (place near other helpers):
Add:

const CONTRACT_SECURITY_CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour

function statusPillColors(theme: any, status: SecurityStatus) {
  if (status === "safe") return { bg: theme.success + "22", fg: theme.success };
  if (status === "warning") return { bg: theme.warning + "22", fg: theme.warning };
  return { bg: theme.textSecondary + "22", fg: theme.textSecondary };
}

function prettifyExtensionName(ext: any): string {
  // ext may be enum number; @solana/spl-token enums are usually reversible by name lookup in TS,
  // but in runtime we’ll just string-cast and fallback.
  return String(ext)
    .replace(/([a-z])([A-Z])/g, "$1 $2")
    .replace(/_/g, " ")
    .trim();
}

async function fetchMetaplexImmutability(connection: any, mint: PublicKey) {
  try {
    // PDA
    let metadataPda: PublicKey;
    try {
      metadataPda = findMetadataPda(mint);
    } catch (e) {
      const [pda] = PublicKey.findProgramAddressSync(
        [
          Buffer.from("metadata"),
          new PublicKey(MPL_TOKEN_METADATA_PROGRAM_ID).toBuffer(),
          mint.toBuffer(),
        ],
        new PublicKey(MPL_TOKEN_METADATA_PROGRAM_ID)
      );
      metadataPda = pda;
    }

    const acc = await connection.getAccountInfo(metadataPda);
    if (!acc?.data) {
      return {
        status: "not_checked" as SecurityStatus,
        subtitle: "No Metaplex metadata account found",
        label: "Not checked yet",
      };
    }

    // Decode
    let md: any;
    try {
      md = Metadata.deserialize(acc.data)[0];
    } catch (e) {
      // if deserialize signature differs in your version, adjust accordingly
      return {
        status: "not_checked" as SecurityStatus,
        subtitle: "Metadata format not decoded yet",
        label: "Not checked yet",
      };
    }

    const isMutable = !!md?.isMutable;
    const updateAuth = md?.updateAuthority?.toBase58?.() ?? null;

    if (isMutable) {
      return {
        status: "warning" as SecurityStatus,
        subtitle: "Metadata is mutable (can be changed by update authority)",
        label: "Warning",
      };
    }

    // Some tokens set isMutable=false but still have updateAuthority (still effectively locked for metadata edits).
    return {
      status: "safe" as SecurityStatus,
      subtitle: "Metadata is immutable",
      label: "Safe",
    };
  } catch (e) {
    return {
      status: "not_checked" as SecurityStatus,
      subtitle: "Metaplex check not available",
      label: "Not checked yet",
    };
  }
}

async function scanContractSecurity(connection: any, mintStr: string): Promise<ContractSecurityResult> {
  const mint = new PublicKey(mintStr);

  // Determine token program by mint account owner
  const mintAcc = await connection.getAccountInfo(mint);
  const owner = mintAcc?.owner?.toBase58?.() ?? "";

  const isToken2022 = owner === TOKEN_2022_PROGRAM_ID.toBase58();
  const programLabel = isToken2022 ? "Token-2022" : "SPL";

  // Read mint using spl-token
  // IMPORTANT: pass the right programId so Token-2022 mint returns tlvData
  const programId = isToken2022 ? TOKEN_2022_PROGRAM_ID : TOKEN_PROGRAM_ID;
  const mintInfo: any = await getMint(connection, mint, "confirmed", programId);

  const mintAuthorityExists = !!mintInfo?.mintAuthority;
  const freezeAuthorityExists = !!mintInfo?.freezeAuthority;

  const items: SecurityItem[] = [];

  items.push({
    key: "token_program",
    title: "Token Program",
    subtitle: isToken2022 ? "Extended token functionality" : "Standard SPL token",
    status: "safe",
    statusLabel: programLabel,
  });

  items.push({
    key: "mintable",
    title: "Mintable",
    subtitle: mintAuthorityExists ? "Mint authority exists — supply can increase" : "No mint authority — supply is fixed",
    status: mintAuthorityExists ? "warning" : "safe",
    statusLabel: mintAuthorityExists ? "Warning" : "Safe",
  });

  items.push({
    key: "freezable",
    title: "Freezable",
    subtitle: freezeAuthorityExists ? "Freeze authority exists — accounts can be frozen" : "No freeze authority — accounts safe",
    status: freezeAuthorityExists ? "warning" : "safe",
    statusLabel: freezeAuthorityExists ? "Warning" : "Safe",
  });

  // Token-2022 Extensions parsing
  if (isToken2022) {
    try {
      // getMint should include tlvData for token-2022
      const tlvData = mintInfo?.tlvData;
      if (tlvData) {
        const exts = getExtensionTypes(tlvData);
        if (exts?.length) {
          const extNames = exts.map(prettifyExtensionName);

          // classify: some extensions affect safety/usability
          // (We keep it simple: show list + mark as Safe/Warning depending on presence of known “control” features)
          const riskyKeywords = ["TransferHook", "PermanentDelegate", "DefaultAccountState", "TransferFee", "Confidential"];
          const hasRisky = extNames.some(n => riskyKeywords.some(k => n.replace(/\s/g,"").includes(k)));

          items.push({
            key: "extensions",
            title: "Token Extensions",
            subtitle: extNames.join(", "),
            status: hasRisky ? "warning" : "safe",
            statusLabel: hasRisky ? "Review" : "Safe",
          });
        } else {
          items.push({
            key: "extensions",
            title: "Token Extensions",
            subtitle: "No extensions detected",
            status: "safe",
            statusLabel: "Safe",
          });
        }
      } else {
        items.push({
          key: "extensions",
          title: "Token Extensions",
          subtitle: "Not checked yet (mint TLV data not available)",
          status: "not_checked",
          statusLabel: "Not checked yet",
        });
      }
    } catch (e) {
      items.push({
        key: "extensions",
        title: "Token Extensions",
        subtitle: "Not checked yet (extension parsing not implemented)",
        status: "not_checked",
        statusLabel: "Not checked yet",
      });
    }
  }

  // Metaplex metadata immutability (applies to both SPL + 2022 if they use Metaplex)
  const md = await fetchMetaplexImmutability(connection, mint);
  items.push({
    key: "metadata_immutability",
    title: "Metadata Immutability",
    subtitle: md.subtitle,
    status: md.status,
    statusLabel: md.label,
  });

  return {
    items,
    scannedAtMs: Date.now(),
    scannedBy: "Cordon",
  };
}

async function loadCachedContractSecurity(mint: string) {
  try {
    const raw = await AsyncStorage.getItem(`contractSecurity:${mint}`);
    if (!raw) return null;
    const parsed = JSON.parse(raw) as ContractSecurityResult;
    if (!parsed?.scannedAtMs) return null;
    const isStale = Date.now() - parsed.scannedAtMs > CONTRACT_SECURITY_CACHE_TTL_MS;
    return { parsed, isStale };
  } catch {
    return null;
  }
}

async function saveCachedContractSecurity(mint: string, data: ContractSecurityResult) {
  try {
    await AsyncStorage.setItem(`contractSecurity:${mint}`, JSON.stringify(data));
  } catch {}
}

Step 4 — Add state in AssetDetailScreen.tsx:
Add near other useState:
const [contractSecurity, setContractSecurity] = useState<ContractSecurityResult | null>(null);
const [isScanningSecurity, setIsScanningSecurity] = useState(false);
const [isSecurityExpanded, setIsSecurityExpanded] = useState(true);

Step 5 — Trigger scan when About tab opens (and allow Rescan):
Add an effect that runs when:
- activeTab becomes "about"
- address/mint is available
- connection is available

Pseudo:
useEffect(() => {
  if (activeTab !== "about") return;
  if (!address) return; // mint address
  let cancelled = false;

  (async () => {
    const cached = await loadCachedContractSecurity(address);
    if (cached?.parsed && !cancelled) setContractSecurity(cached.parsed);

    // Auto scan if no cache OR stale
    if (!cached?.parsed || cached.isStale) {
      setIsScanningSecurity(true);
      try {
        const result = await scanContractSecurity(connection, address);
        if (!cancelled) {
          setContractSecurity(result);
          saveCachedContractSecurity(address, result);
        }
      } finally {
        if (!cancelled) setIsScanningSecurity(false);
      }
    }
  })();

  return () => { cancelled = true; };
}, [activeTab, address, connection]);

Add a handler:
const onRescanSecurity = async () => {
  if (!address) return;
  setIsScanningSecurity(true);
  try {
    const result = await scanContractSecurity(connection, address);
    setContractSecurity(result);
    saveCachedContractSecurity(address, result);
  } finally {
    setIsScanningSecurity(false);
  }
};

Step 6 — Update About UI (renderAboutTab):
Under Links section, insert a new section:

<ThemedText type="h4" style={{ marginBottom: Spacing.md }}>
Contract Security
</ThemedText>

Create a card container similar to your statsCard but with:
- Header row: "Contract Security" + pill "Scanned" + (Rescan button on right)
- Subheader: "Scanned by Cordon • just now" (or time ago)
- Expand/collapse chevron
- Body: list rows

Each row:
- left: icon placeholder (use your existing icon system or simple ✅ / ⚠️ / ? as text)
- middle: Title + subtitle
- right: status pill
Important: If status is not_checked, show pill text "Not checked yet" (NOT “Unknown”).

Also add small footnote:
"Based on on-chain checks. Not checked yet = verification not supported yet."

Step 7 — Styling additions:
Add styles:
securityCard, securityHeaderRow, securityRow, securityIcon, securityTextWrap, securityPill, rescanButton, etc.
Match your current theme look.

Step 8 — Make sure it works for both SPL + Token-2022:
- SPL: shows Token Program=SPL, Mintable, Freezable, Metadata Immutability
- Token-2022: shows Token Program=Token-2022, Mintable, Freezable, Token Extensions list, Metadata Immutability

Acceptance tests:
1) Open a known Token-2022 mint -> should show Token Extensions with a list (not “Unknown”).
2) Open a simple SPL mint -> no extensions section (or omit it) and no “Unknown”.
3) Rescan updates “Scanned by Cordon • just now”.
4) No crashes if metadata account missing -> show “Not checked yet (No Metaplex metadata account found)”