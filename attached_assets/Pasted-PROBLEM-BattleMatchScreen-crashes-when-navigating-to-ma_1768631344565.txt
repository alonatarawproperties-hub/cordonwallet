PROBLEM: BattleMatchScreen crashes when navigating to match after matchmaking

ROOT CAUSE: Complete data structure mismatch between server response and client expectations

CLIENT EXPECTS (BattleMatchScreen.tsx lines 36-70):

interface BattleRoachy {
  id: string;
  name: string;
  class: RoachyClass;  // NOT roachyClass
  hp: number;
  maxHp: number;
  atk: number;
  def: number;
  spd: number;
  isAlive: boolean;  // NOT isKO
  skillA: Skill;
  skillB: Skill;
  cooldowns: { skillA: number; skillB: number };
}
interface MatchState {
  matchId: string;
  turn: number;  // NOT currentTurn
  maxTurns: number;
  phase: "SELECTION" | "RESOLUTION" | "FINISHED";  // NOT status
  player: PlayerState;  // NOT player1
  opponent: PlayerState;  // NOT player2
  turnTimeLeft: number;
  winner?: string;
  winReason?: string;
}
SERVER RETURNS (battle-routes.ts lines 800-830):

{
  success: true,
  match: {
    matchId: string,
    status: 'team_select' | 'active' | 'completed',  // WRONG - client expects 'phase'
    currentTurn: number,  // WRONG - client expects 'turn'
    player1: { playerId, momentum, kos, team, activeIndex },  // WRONG - client expects 'player'
    player2: { ... },  // WRONG - client expects 'opponent'
    // Missing: maxTurns, turnTimeLeft
  }
}
QUERY ISSUE (BattleMatchScreen.tsx line 165-170):

const { data: matchState } = useQuery<MatchState>({
  queryKey: ["/api/battles/match", matchId],
});
The default fetcher returns response.json() which gives { success, match }, but the code expects the MatchState directly. So matchState.phase is undefined, matchState.player is undefined, causing crashes.

THREE MISMATCHES TO FIX:

Wrapper vs direct data: Server returns { success, match }, client expects MatchState directly
Field naming: status vs phase, currentTurn vs turn, player1/player2 vs player/opponent
BattleRoachy format: roachyClass vs class, nested stats vs flat properties, isKO vs isAlive
FIX OPTIONS:
A) Transform server response in client's query (add select to extract and transform)
B) Update server endpoint to return data in client-expected format
C) Update client interfaces to match server format

