FIX: "Wallet is locked or mnemonic not found" when sending (Expo Go)

Problem:
- Balances work (RPC is fine)
- Sending fails with: Wallet is locked or mnemonic not found
Meaning: the signing layer cannot access the decrypted secret at send time.

Goal:
- After unlocking with PIN, the app should have an in-memory signing session.
- sendNative/sendERC20 must always be able to get the active wallet signer while unlocked.
- If locked, Send should automatically prompt for unlock instead of failing.

A) Implement a proper unlock/session model in /packages/core
1) Separate STORAGE vs SESSION:
- Storage (SecureStore): encrypted vault blob only.
- Session (in-memory): decrypted secrets cached ONLY while app is unlocked.

2) Vault format must include secrets for each wallet id:
VaultDecrypted = {
  version: 1,
  wallets: [{id,name,address,createdAt}],
  activeWalletId: string,
  secretsByWalletId: Record<walletId, { mnemonic?: string; privateKey?: `0x${string}` }>
}

3) On unlockWithPin(pin):
- Read encrypted vault from SecureStore
- Decrypt into VaultDecrypted
- Store VaultDecrypted ONLY in memory (do not write plaintext to disk)
- Set an isUnlocked flag true

4) Add functions:
- requireUnlocked(): throws a specific error if locked
- getActiveSigner(chainId): returns a viem account/walletClient-ready signer derived from secretsByWalletId[activeWalletId]
- lock(): clears in-memory VaultDecrypted and sets isUnlocked false

B) Fix sendNative/sendERC20 to use the session signer
- Remove any direct “load mnemonic from SecureStore” calls inside send functions.
- sendNative/sendERC20 must call getActiveSigner() which uses the decrypted in-memory session.
- If locked, throw a typed error code, e.g. WALLET_LOCKED.

C) UX fix: prompt unlock instead of failing
- In the mobile Send flow, before building/signing:
  - call requireUnlocked()
  - if locked: show Unlock modal/screen (PIN) then resume sending automatically

D) Handle Expo Go reload/background
- When app goes background, call lock() after a short timeout (e.g. 30s) OR immediately (simple is fine).
- On returning to foreground, require PIN again for signing.
- Ensure the UI state reflects locked/unlocked properly.

E) Debug logging (temporary)
Add dev logs (only in dev) around send:
- isUnlocked?
- activeWalletId?
- has secret for activeWalletId?
- securestore vault exists?

DONE WHEN:
- I can unlock once, then send MATIC successfully (real tx hash) on Polygon.
- If I lock or restart, Send prompts unlock instead of throwing “mnemonic not found”.
- Multi-wallet works: each wallet can sign if it has a stored secret.