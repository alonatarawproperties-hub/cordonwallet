REPLIT ONE-CLICK PROMPT — IMPLEMENT CORDON TOKEN SAFETY V2-A + V2-C (Solana SPL + Token-2022) + SHOW IT IN SWAP + ASSET ABOUT

Goal
Upgrade Cordon’s “Token Safety / Contract Security” from basic mint/freeze checks into a competitive scanner:
✅ V2-A (must ship now): authorities + metadata immutability + top holder concentration + liquidity presence + basic market stats
✅ V2-C (must ship now, best-effort + clearly labeled): deployer/authority history + holder clustering heuristics + suspicious volume/wash flags
Works for BOTH SPL Token program and Token-2022.
Must be human-readable + explainable (“tap to see proof”), and usable as a pre-swap gate.

Hard rules
1) Do NOT re-architect the whole app. Keep changes minimal and safe.
2) Must not break Swap or Asset detail. Handle missing data gracefully.
3) No “Unknown” without explanation. If we cannot verify something, show “Not verified (yet)” + why.
4) Cache results per mint for a short TTL and allow “Rescan”.
5) Must run on mobile (Expo / RN). Avoid Node-only libs.
6) Keep Jupiter platform fees disabled (already handled). This task is ONLY scanner + UI gate.

Where to implement
Primary UI screens (existing):
- client/screens/AssetDetailScreen.tsx (About tab already exists)
- client/screens/SwapScreen.tsx (Token Safety modal already exists in your UI screenshots)

Add new services (NEW files; small + focused):
- client/services/tokenSafetyV2.ts
- client/services/dexMarketData.ts
- client/services/solanaMintInfo.ts
- client/services/cache.ts
- client/utils/riskScore.ts
- client/types/tokenSafety.ts

Dependencies
Use existing @solana/web3.js already in project.
Add these only if missing:
- @solana/spl-token (for getMint + TOKEN_PROGRAM_ID + TOKEN_2022_PROGRAM_ID)
Optional but recommended for metadata parsing (Metaplex):
- @metaplex-foundation/mpl-token-metadata
If mpl-token-metadata causes bundling issues, fall back to “Metadata mutable check: Not verified (Metaplex parser unavailable)” but STILL show updateAuthority if we can fetch via mpl package; if not, show not verified with reason.

----------------------------------------------------------------------------------------------------
A) DATA MODEL (client/types/tokenSafety.ts)

Create types to represent V2 results with proof and explanations:

export type SafetyLevel = "safe" | "warning" | "danger" | "info";
export type VerificationState = "verified" | "not_verified" | "unavailable";

export interface SafetyFinding {
  key: string;                // e.g. "mintable"
  title: string;              // "Mintable"
  level: SafetyLevel;         // safe/warning/danger/info
  summary: string;            // short line (human-readable)
  detail: string;             // longer explanation
  verified: VerificationState;// verified vs not_verified vs unavailable
  proof?: {
    label: string;            // "Mint authority"
    value: string;            // pubkey or number
    explorerUrl?: string;
  }[];
}

export interface TokenSafetyReportV2 {
  mint: string;
  chain: "solana";
  tokenProgram: "spl" | "token2022" | "unknown";
  scannedAt: number;          // ms epoch
  sourceLabel: string;        // "Scanned by Cordon"
  findings: SafetyFinding[];

  // V2-A numeric stats (if available)
  stats?: {
    supply?: string;          // ui amount string
    decimals?: number;
    topHoldersPct?: number;   // 0-100
    topHoldersCount?: number; // e.g. 10
    liquidityUsd?: number;    // from DexScreener if available
    volume24hUsd?: number;
    fdvUsd?: number;
    marketCapUsd?: number;    // if Dex provides
  };

  // V2-C heuristics (best effort)
  heuristics?: {
    authorityChangedRecently?: boolean;
    deployerOrAuthority?: string; // pubkey used for history checks
    suspiciousVolume?: boolean;
    clusteredTopHolders?: boolean;
    notes?: string[];
  };

  // final verdict
  verdict: {
    label: "Low Risk" | "Medium Risk" | "High Risk";
    level: "safe" | "warning" | "danger";
    reasons: string[];        // top 2-4 reasons (human readable)
  };
}

----------------------------------------------------------------------------------------------------
B) CACHE (client/services/cache.ts)

Implement a tiny in-memory cache with TTL:
- key: `tokenSafetyV2:${mint}`
- store { value, expiresAt }
- default TTL: 5 minutes
- support forceRefresh boolean

----------------------------------------------------------------------------------------------------
C) SOLANA MINT + AUTHORITIES + TOKEN PROGRAM DETECTION (client/services/solanaMintInfo.ts)

Implement:
1) detectTokenProgram(connection, mintPubkey):
   - try getAccountInfo(mint)
   - check owner === TOKEN_PROGRAM_ID => "spl"
   - owner === TOKEN_2022_PROGRAM_ID => "token2022"
   - else "unknown"

2) fetchMintCore(connection, mintPubkey, program):
   For SPL or Token-2022:
   - use getMint(connection, mintPubkey, undefined, programId)
   Return:
   - decimals
   - supply (bigint)
   - mintAuthority (pubkey | null)
   - freezeAuthority (pubkey | null)

3) metadata immutability + update authority:
   - If using mpl-token-metadata:
     - derive metadata PDA:
       seeds = ["metadata", TOKEN_METADATA_PROGRAM_ID, mint]
     - fetch account and decode Metadata
     - get updateAuthority + isMutable + name/symbol/uri (optional)
   - If unavailable, return verified=not_verified with reason.

IMPORTANT:
- All findings must include “proof” (pubkeys + explorer links).
- Always handle errors without crashing.

----------------------------------------------------------------------------------------------------
D) TOP HOLDERS CONCENTRATION (V2-A) (client/services/tokenSafetyV2.ts)

Implement:
fetchTopHoldersPct(connection, mintPubkey, supply, decimals):
- connection.getTokenLargestAccounts(mintPubkey)
- take top 10 (or configurable)
- sum uiAmount (or amount) for those accounts
- topPct = (sumTop / totalSupply) * 100
Return { topPct, topCount: 10, largestAccounts: [{address, amount}] }

Notes:
- Some mints may have weird supply; if supply == 0 => not_verified with explanation.
- Provide a finding:
  Title: "Holder concentration"
  - Safe if top10 <= 20%
  - Warning if 20–40%
  - Danger if > 40%
  Provide detail explaining what it means and why it matters.

----------------------------------------------------------------------------------------------------
E) LIQUIDITY PRESENCE + MARKET DATA (V2-A + supports V2-C) (client/services/dexMarketData.ts)

Use DexScreener public API (simple + fast):
GET https://api.dexscreener.com/latest/dex/tokens/{mint}

Parse:
- pairs[0] as best pair (highest liquidityUsd)
- liquidity.usd
- volume.h24
- fdv
- marketCap (if present)
- dexId / url / baseToken / quoteToken
Return normalized object.

If API fails:
- mark liquidity as not_verified with reason: “Market data source unavailable”

Add findings:
1) “Liquidity”
   - Safe if liquidityUsd >= 50k
   - Warning if 10k–50k
   - Danger if < 10k OR no pool found
2) “24h Volume”
   - Info by default; warning if volume is huge relative to liquidity (wash risk heuristic)

----------------------------------------------------------------------------------------------------
F) V2-C HEURISTICS (best-effort but valuable) (client/services/tokenSafetyV2.ts)

1) “Authority risk & history (best-effort)”
We can’t reliably get “deployer” on-device without heavy pagination.
So:
- Use updateAuthority if available, else mintAuthority if exists, else “unknown”.
- Heuristic: “Authority present” is already a risk (mint/freezable/mutable metadata).
- Additionally: check whether updateAuthority has recent activity:
  - connection.getSignaturesForAddress(authorityPubkey, { limit: 10 })
  - if very recent + token is new => note “Authority wallet active recently” (info/warn)
This is NOT a rug proof; label as heuristic.

2) “Clustered top holders (heuristic)”
For top 10 token accounts:
- Fetch owner wallets via getParsedAccountInfo(tokenAccount)
- For each owner wallet:
  - getSignaturesForAddress(owner, { limit: 5 })
  - extract the most recent transaction’s feePayer (requires getTransaction for that signature) OR if too heavy, skip feePayer and just count “freshness”
Heuristic flags:
- Many top holders are very new (e.g., < 5 tx signatures available) => warning
- Many top holders funded around same time (if feePayer repeats) => warning
Keep this optional; timebox to avoid freezing UI:
- max 5 holders deep-check per scan
- use Promise.race with timeout (e.g., 2500ms)
If timeouts: show “Not verified yet (deep scan timed out)” not “Unknown”.

3) “Suspicious volume / wash (heuristic)”
Using DexScreener:
- if volume24hUsd > liquidityUsd * 8 => warning “Volume unusually high vs liquidity (possible wash trading)”
- if priceChange24h huge and liquidity low => warning
Again label as heuristic.

Every heuristic must be clearly labeled “Heuristic” in detail text.

----------------------------------------------------------------------------------------------------
G) RISK SCORING (client/utils/riskScore.ts)

Compute verdict from findings:
- If any danger findings verified => High Risk
- Else if >=2 warnings verified => Medium Risk
- Else Low Risk
Reasons: pick top 2-4 findings summaries.

----------------------------------------------------------------------------------------------------
H) TOKEN SAFETY V2 SERVICE (client/services/tokenSafetyV2.ts)

Export:
export async function getTokenSafetyV2(params: {
  connection;
  mint: string;
  forceRefresh?: boolean;
}): Promise<TokenSafetyReportV2>

Steps:
1) cache lookup (5min TTL)
2) detect token program + fetchMintCore
3) fetch metadata mutability/updateAuthority (best effort)
4) fetch top holders pct
5) fetch dexscreener market data (best pair)
6) run heuristics with timeouts
7) build findings array in this order:
   - Token program (SPL vs Token-2022)
   - Mintable
   - Freezable
   - Metadata immutability
   - Holder concentration
   - Liquidity
   - Volume 24h (info)
   - Heuristics: clustered holders (heuristic), suspicious volume (heuristic), authority activity (heuristic)
8) compute verdict

Make sure ALL findings have:
- clear label badge (Safe/Warning/Danger/Info)
- verified state
- proof links:
  - explorerUrl = `https://solscan.io/account/${pubkey}` or `https://solscan.io/token/${mint}`

----------------------------------------------------------------------------------------------------
I) UI — ASSET DETAIL “ABOUT” TAB (client/screens/AssetDetailScreen.tsx)

1) Add local state:
- tokenSafetyV2Report, isSafetyLoading, lastSafetyError
2) When About tab becomes active OR when screen opens:
- call getTokenSafetyV2({ mint: address })
3) Add a new “Contract Security” section that matches the style you already started, but now includes:
- header row: “Contract Security” + chip “Scanned” + small text “Scanned by Cordon • just now / Xm ago”
- a “Rescan” button on right
- show verdict chip (Low/Medium/High)
- render findings as a list of rows with:
  - icon (check / warning / danger / info)
  - title
  - summary (one line)
  - badge on right (“Safe”, “Warning”, “Risk”, “Info”, “Not verified”)
- Tapping a row opens a bottom sheet / modal showing:
  - detail text
  - proof items (pubkey + open in browser)
If you don’t have a bottom sheet component, reuse the existing modal style from Swap safety modal.

4) Remove “Unknown” wording:
Replace with:
- “Not verified yet” (when we didn’t run it)
- “Unavailable” (when chain/program doesn’t support)
And ALWAYS include why.

5) Keep existing Stats + Links sections; enrich Stats with marketCap/liquidity/volume if dexscreener data exists.

----------------------------------------------------------------------------------------------------
J) UI — SWAP “PRE-SWAP SAFETY GATE” (client/screens/SwapScreen.tsx)

Before executing swap:
1) When output token changes OR user enters amount OR route is determined:
- Pre-fetch getTokenSafetyV2 for outputMint (and inputMint optionally).
2) Add an inline “Safety” chip near the route info:
- “Low Risk / Medium Risk / High Risk”
- tapping opens Token Safety modal (the one in your screenshot)
3) On pressing “Swap”:
- If verdict is High Risk => show confirmation modal:
  “High Risk token. Reasons: …”
  Buttons: “Cancel” and “Swap anyway”
- If Medium Risk => show lighter confirm
- Low risk => proceed normally
4) If scan not verified / timed out:
- show modal “Scan not ready yet (takes ~2s). Rescan or proceed?”
This prevents “we look dumb”.

IMPORTANT: Don’t block swaps forever. User can proceed with explicit acknowledgement.

----------------------------------------------------------------------------------------------------
K) COPY + WORDING (human readable)

Use this tone:
- “Verified = on-chain facts”
- “Heuristic = pattern-based, not guaranteed”
- “Not financial advice”
No scary legal text, just clear.

Examples:
- Metadata immutability (verified): “Mutable metadata — issuer can change token metadata.”
- Token extensions (not implemented yet): “Not verified yet — Token-2022 extensions decoding is coming.”

----------------------------------------------------------------------------------------------------
L) PERFORMANCE + SAFETY

- Add a timeout wrapper utility in tokenSafetyV2.ts:
  withTimeout(promise, ms)
- DexScreener call should be cancellable-ish: ignore results if timed out.
- Deep scans (cluster) max 2.5s total.
- Never crash UI if a fetch fails.

----------------------------------------------------------------------------------------------------
M) WHAT TO DELIVER

1) New files listed above.
2) AssetDetailScreen.tsx updated to show V2 Contract Security section (detailed like Trust Wallet, but “Scanned by Cordon”)
3) SwapScreen.tsx updated:
   - shows safety chip
   - uses V2 modal
   - adds pre-swap risk gate confirmation
4) Make sure it works for SPL and Token-2022 mints.
5) Add a small developer log only in dev mode if scans fail.

After implementation, provide me:
- what files changed
- how to test quickly on device:
  - open asset > about > rescan
  - go to swap and try a risky pump token

DO NOT TALK ABOUT FEES IN THIS TASK. This is only TokenSniffer/RugCheck-style scanning + swap safety UX.