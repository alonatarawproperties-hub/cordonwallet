You are a senior engineer. Implement REAL EVM mainnet Approvals + Revoke + Firewall enforcement in the existing Cordon wallet codebase. We are using MAINNET ONLY (Ethereum/Polygon/BNB). Do NOT add any testnet toggles.

GOAL
1) Approvals screen shows REAL approvals created by Cordon (MVP approach).
2) Revoke works on-chain (approve(spender, 0)) and returns a real tx hash.
3) Firewall enforces approval rules across ALL signing paths:
   - Send screens (already)
   - Any in-app approve flow (swap/permit if present)
   - WalletConnect eth_sendTransaction requests
4) Firewall blocks NEW unlimited approvals by default and offers a safe alternative: "Cap allowance".

IMPORTANT
- Never scan full chain or require paid indexers for MVP.
- We will track approvals created by this wallet and manage/revoke those reliably.
- All txs must be signed locally (non-custodial) and broadcast to mainnet RPC.

-----------------------------------------
A) DATA MODEL + STORAGE (NON-SENSITIVE)
Create /packages/core/src/approvals/types.ts

ApprovalRecord = {
  id: string,
  chainId: number,
  owner: `0x${string}`,
  tokenAddress: `0x${string}`,
  tokenSymbol?: string,
  tokenName?: string,
  tokenDecimals?: number,
  spender: `0x${string}`,
  spenderLabel?: string,           // e.g. "Uniswap Router" if known
  allowanceRaw: string,            // bigint serialized
  allowanceFormatted?: string,
  isUnlimited: boolean,
  createdAt: number,
  txHash: `0x${string}`,
  status: 'pending'|'confirmed'|'failed',
  lastCheckedAt?: number
}

Store approvals locally (non-sensitive):
- Use AsyncStorage (preferred) or SecureStore if you already use it.
- Key by owner+chainId to support multi-wallet.
Create /packages/core/src/approvals/store.ts:
- saveApproval(record)
- listApprovals({owner, chainId}) => records sorted desc
- updateApprovalStatus(txHash, status)
- removeApproval(id)
- upsertByKey(owner+chainId+token+spender)

-----------------------------------------
B) APPROVAL DETECTION (EVM) — REAL
Create /packages/core/src/approvals/detect.ts

Implement:
- detectApproveIntent(tx) -> { tokenAddress, spender, amountRaw, isUnlimited }
Using viem decodeFunctionData against ERC20 ABI for approve(address,uint256).

Max uint256 constant:
- 2n**256n - 1n

When Cordon is about to sign/broadcast any tx:
- If it is an approve() call, create/update an ApprovalRecord in the store with status 'pending' immediately after broadcast.
- After confirmation, update to confirmed/failed.

-----------------------------------------
C) REVOKE (ON-CHAIN) — REAL
Create /packages/core/src/approvals/revoke.ts

Implement revokeApproval({
  chainId,
  walletId or owner,
  tokenAddress,
  spender
}) -> { hash, explorerUrl }

How:
- Build an ERC20 approve(spender, 0) tx.
- Run Firewall preview before signing (still applies).
- Sign and broadcast via existing signer/session.
- Save a TxRecord in Activity and update ApprovalRecord:
  - allowanceRaw becomes "0"
  - status pending then confirmed when receipt found

UI:
- Tapping Revoke triggers a "Before you sign" preview sheet.
- After success show tx hash + explorer link.

-----------------------------------------
D) FIREWALL RULES FOR APPROVALS (MAIN FEATURE)
Update /packages/core/src/firewall/policy.ts and decode logic:

1) If tx is approve() and amountRaw == MAX_UINT256 and policy.blockUnlimitedApprovals == true:
   - BLOCK with reason:
     "Unlimited approvals can allow token drains. Use a capped allowance instead."
2) Provide SAFE ALTERNATIVE in UI:
   - "Cap allowance" button:
     - user enters amount (default suggestion: last transfer amount OR a small preset)
     - replace approve amountRaw with capped amountRaw
     - re-run policy => should allow
3) Denylist always blocks.
4) Add per-tx spend cap for approvals too:
   - If cap > user configured maxAllowancePerTx (optional) -> warn/block.

IMPORTANT:
- Blocking must apply to:
  - Any internal approve flow (swap/approve)
  - WalletConnect eth_sendTransaction if data decodes to approve()

-----------------------------------------
E) WALLETCONNECT ENFORCEMENT (EVM)
Locate WalletConnect eth_sendTransaction handling and ensure:
- Convert request to tx object
- Run Firewall preview BEFORE signing
- If Firewall blocks (e.g., unlimited approve), reject the WC request with a clear error message
- If user chooses cap allowance, modify tx data to capped approve and proceed
- After broadcast, return tx hash to dApp

If WalletConnect isn't fully implemented yet, implement minimal required:
- Connect session
- Handle eth_sendTransaction and personal_sign
- Focus on eth_sendTransaction approval path.

-----------------------------------------
F) APPROVALS SCREEN (MOBILE UI) — REAL
Replace any placeholder/mock approvals list.

Screen behavior:
1) Load approvals via listApprovals({owner: activeEvmAddress, chainId: selectedEvmChainId})
2) For each record show:
- Token symbol/name
- Spender label or shortened address
- Allowance (formatted) and "Unlimited" badge if unlimited
- Status (Pending/Confirmed/Failed)
- Revoke button
3) If the record isUnlimited and blockUnlimitedApprovals==true:
- show a red "Blocked by policy" badge
- helper text: "This approval is risky. Revoke to stay safe."
(NOTE: This is a recommendation; it does not mean it is blocked retroactively.)

Receipt/status updates:
- Reuse your existing receipt poller for EVM txs.
- Update approval status based on tx receipt.
- Optionally re-check allowance on-chain for confirmed approvals using allowance(owner, spender).

-----------------------------------------
G) OPTIONAL: KNOWN SPENDER LABELS (LIGHT)
Add a small optional map per chain of known spender addresses:
- Uniswap router, 1inch router, etc. (keep small; if unknown, show address only).
Do NOT break if missing.

-----------------------------------------
H) MAINNET SAFETY DEFAULTS
In Settings/Policy defaults:
- blockUnlimitedApprovals = true
- show warning sheet on any approve() regardless of amount
- require explicit confirmation step on approvals

-----------------------------------------
I) TESTS (CORE)
Add unit tests for:
- detectApproveIntent decodes spender/amount
- policy blocks MAX_UINT approvals when toggle true
- cap allowance path produces non-max approval and becomes allowed

-----------------------------------------
DONE WHEN (ACCEPTANCE)
1) Creating an approval via any flow results in an ApprovalRecord saved (pending->confirmed).
2) Approvals screen displays real tracked approvals (no placeholders).
3) Revoke sends approve(spender, 0) on mainnet and produces real tx hash + explorer link.
4) Firewall blocks NEW unlimited approvals by default and provides "Cap allowance" alternative.
5) WalletConnect approval requests are blocked/capped via the same firewall.

IMPLEMENTATION ORDER
1) approvals types+store
2) detect approve intents + hook into tx broadcast pipeline
3) revokeApproval
4) replace Approvals UI
5) firewall cap allowance UX + enforcement
6) WalletConnect enforcement
7) tests