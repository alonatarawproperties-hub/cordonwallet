REPLIT AGENT PROMPT — FIX “CREATE PIN” SHOWING AGAIN ON 2ND WALLET IMPORT (SAFE, MINIMAL CHANGE)

Goal:
After a user already created a PIN for the app (during first wallet setup), importing a second wallet must NOT ask “Create Your PIN” again. PIN must be device/app-level (global), not per-wallet.

Symptoms:
- User creates Wallet #1 → sets 6-digit PIN (works)
- User imports Wallet #2 → app incorrectly routes to “Create Your PIN”
Expected:
- Only ask “Create PIN” once (first time ever on device)
- Importing additional wallets should just use existing PIN / biometric unlock

Hard constraints (DO NOT BREAK WORKING STUFF):
- Do NOT change cryptography/encryption format of already-saved wallets
- Do NOT overwrite existing PIN
- Do NOT refactor unrelated wallet flows
- Do NOT add new screens
- Keep changes as small as possible

Likely root cause:
The app checks PIN presence per-wallet or in the import flow, instead of checking a global “deviceHasPin” flag stored in secure storage.

Implementation plan (minimal & safe):

1) Add a single source of truth for app-level PIN state
Create/ensure a module (or extend existing) e.g.:
- client/lib/security/pin.ts (or wherever your PIN helpers are)
Expose:
- async function hasDevicePin(): Promise<boolean>
- async function setDevicePin(pin: string): Promise<void>
- async function verifyDevicePin(pin: string): Promise<boolean> (if exists already)

Storage:
- Use SecureStore/Keychain (Expo SecureStore) to store a PIN marker + hash.
- If your app already stores a pinHash, reuse it exactly (do NOT change hashing).
- Store under a stable key like: "CORDON_PIN_HASH" and/or "CORDON_PIN_SET" boolean.
hasDevicePin() should return true if pinHash exists OR pinSet flag exists.

2) Update the navigation/guard logic to be device-level
Find the logic that decides between:
- “CreatePin” screen vs “UnlockPin” screen vs continuing import
Replace any wallet-scoped checks like:
- if (!currentWallet.pinHash) showCreatePin
with:
- if (!(await hasDevicePin())) showCreatePin
- else showUnlockPin or proceed (depending on whether app is currently locked)

3) Fix the Import Wallet flow specifically
In ImportWallet screen/handler (the flow you showed):
- Before routing to CreatePin, call hasDevicePin()
Rules:
A) If hasDevicePin() is FALSE:
   - proceed to CreatePin (first time only)
B) If hasDevicePin() is TRUE:
   - NEVER route to CreatePin
   - If app is locked, route to UnlockPin (or biometric)
   - If app is already unlocked, continue import directly

4) Make sure “CreatePin” is only reachable when device pin is not set
Add a guard in CreatePin screen:
- On mount, if hasDevicePin() is true → immediately navigate back / to Unlock / to home
(Prevents accidental re-entry)

5) Verify wallet encryption remains unchanged
Important:
- Wallet encryption should use the SAME existing app/device secret derived from the PIN.
- Do NOT regenerate a new master key when importing a wallet if a PIN already exists.
- If you currently derive an encryption key on PIN creation, ensure importing a wallet uses the already-derived key (or unlock step) rather than re-creating it.

Acceptance tests (must pass):
1) Fresh install:
   - Import wallet → asked to Create PIN → success
2) After PIN already exists:
   - Import second wallet → should NOT show Create PIN
   - Should go straight to import (if already unlocked) OR ask unlock PIN/biometric (if locked)
3) Existing Wallet #1 must still decrypt/unlock with the old PIN (no migration required)
4) No regressions to Send/Swap/Activity

Deliverables:
- Commit minimal changes only in:
  - PIN helper module (hasDevicePin/set/verify)
  - ImportWallet flow guard
  - CreatePin screen guard
  - Any nav guard that incorrectly checks PIN per-wallet
- Add 2–3 console logs (dev only) for:
  - hasDevicePin result
  - which route was chosen (CreatePin vs Unlock vs Continue)
Remove or gate logs behind __DEV__.

Do it carefully and keep code diff small.