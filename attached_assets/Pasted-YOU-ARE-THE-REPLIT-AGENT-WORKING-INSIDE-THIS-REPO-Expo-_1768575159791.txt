YOU ARE THE REPLIT AGENT WORKING INSIDE THIS REPO (Expo RN client + Express server). DO NOT ASK ME QUESTIONS. IMPLEMENT EVERYTHING BELOW END-TO-END.

GOAL
Fix Solana swap token discovery for ALL tokens (including Pump.fun mints) by upgrading token resolution to:
1) Jupiter token list (fast + verified)
2) Helius DAS getAsset (fast metadata for any mint)
3) Metaplex Token Metadata fallback (on-chain metadata PDA decode + optional offchain JSON fetch)
4) On-chain decimals fallback via getMint()
Add aggressive caching + negative caching to avoid 429/500s.
Also fix UI token picker so pasting a mint shows correct symbol/name/logo/decimals and can be selected.
Also reduce quote refresh spam (default 12s; optional “Live quotes” toggle for traders).

IMPORTANT CONSTRAINTS
- Keep wallet NON-CUSTODIAL. Server is allowed to fetch quotes/metadata and build swap tx, but MUST NOT hold keys or sign user tx.
- The existing swap already works (server-assisted). This task is token detection + stability + rate limit fixes.
- Keep current architecture: /server/swap routes + client SwapScreen uses server endpoints.

===========================================================
A) SERVER: token resolution (Helius DAS + Metaplex + caching)
===========================================================

1) Add dependencies (server-side only; root package.json is shared, so add to dependencies):
- @metaplex-foundation/mpl-token-metadata
- node-fetch (ONLY if global fetch is not available in your node runtime; check first. If Node 18+ is used, prefer global fetch.)
After editing package.json run npm install (or let Replit handle).

2) In server/swap/tokenlist.ts implement FULL token resolver.
You said current file has:
- HARDCODED_TOKENS
- getTokenList(), getToken()
- resolveToken() that falls back to getMint() only (UNKNOWN)

Replace/upgrade resolveToken() to this robust flow:

NEW TYPES:
- Extend TokenInfo (server/swap/types if needed) to include:
  verified?: boolean;          // true ONLY if from Jupiter list
  sources?: string[];          // e.g. ["hardcoded","jupiter","helius-das","metaplex","on-chain"]
  lastUpdated?: number;        // Date.now()
  tags?: string[];             // optional e.g. ["pumpfun"] if mint ends with "pump"
  isCustom?: boolean;          // true if user pasted mint (not in Jupiter)
- Create a CustomTokenCacheEntry:
  { token: TokenInfo; expiresAt: number; negative?: boolean; }
- customTokenCache: Map<string, CustomTokenCacheEntry>

CACHE POLICY (IMPORTANT FOR 429/500):
- Jupiter list: stale-while-revalidate:
  - memory TTL: 6 hours
  - disk cache TTL: 24 hours
  - if fetch fails (500), return last disk cache (if exists) + HARDCODED_TOKENS
- Custom token resolution cache:
  - success TTL: 24 hours
  - negative cache (if mint invalid or no decimals found): 5 minutes
- For Helius + Metaplex + offchain JSON:
  - Add per-mint “inflight” dedupe (Map<mint, Promise<TokenInfo>>) so 10 UI calls don’t spam upstream.
  - Add small rate limiter for upstream calls: max 5 concurrent external fetches.

IMPLEMENT THESE HELPERS IN tokenlist.ts:

a) validateMint(mint: string): PublicKey
- Use new PublicKey(mint) inside try/catch.
- If invalid, throw “Invalid mint”.

b) getHeliusEndpoint():
- Use process.env.HELIUS_API_KEY if present OR if your SOLANA_RPC_URL contains helius key.
- Prefer explicit HELIUS_API_KEY.
- Build URL: https://mainnet.helius-rpc.com/?api-key=KEY

c) fetchHeliusDASAsset(mint: string):
- POST JSON-RPC:
  {
    "jsonrpc":"2.0","id":"cordon","method":"getAsset","params":{"id": mint}
  }
- Parse result:
  - name: result?.content?.metadata?.name OR result?.content?.metadata?.name (trim)
  - symbol: result?.content?.metadata?.symbol (trim)
  - image: result?.content?.links?.image OR result?.content?.files?.[0]?.uri
  - decimals: result?.token_info?.decimals (if present)
Return partial { name, symbol, logoURI, decimals } plus source "helius-das".
Add 4s timeout + 1 retry (only on network/429/5xx with backoff 500ms).

d) fetchMetaplexMetadata(mint: string, connection: Connection):
- Derive metadata PDA:
  seeds = ["metadata", TOKEN_METADATA_PROGRAM_ID, mintPubkey]
  TOKEN_METADATA_PROGRAM_ID = new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")
- Use mpl-token-metadata to deserialize:
  import { Metadata } from "@metaplex-foundation/mpl-token-metadata"
  const acct = await connection.getAccountInfo(pda)
  if (!acct) return null
  const [metadata] = Metadata.deserialize(acct.data)
- Extract:
  symbol = metadata.data.symbol (trim)
  name = metadata.data.name (trim)
  uri = metadata.data.uri (trim)
- Optional offchain JSON fetch (ONLY if uri is http(s)):
  - fetch with 4s timeout
  - parse JSON
  - image = json.image
Return partial { name, symbol, logoURI } with source "metaplex".

e) fetchOnChainDecimals(mint: string, connection: Connection):
- Use getMint(connection, new PublicKey(mint)) to read decimals.

f) buildTokenInfo(mint, partials, decimalsFallback):
- Decide final decimals:
  - prefer Jupiter decimals
  - else Helius decimals
  - else on-chain decimals
- Decide final display:
  - symbol: Jupiter > Helius > Metaplex > fallback to "UNKNOWN"
  - name: Jupiter > Helius > Metaplex > fallback "Unknown Token"
  - logoURI: Jupiter > Helius image > Metaplex offchain image > ""
- verified = true only if Jupiter.
- isCustom = !verified
- tags: if mint endsWith("pump") add ["pumpfun"] (this is only a UI hint)
- sources: include all used sources in order.
- lastUpdated = Date.now()

NEW resolveToken(mint: string):
- Validate mint (PublicKey).
- Check HARDCODED_TOKENS first.
- Check customTokenCache:
  - if entry exists and not expired, return entry.token (even if negative; in negative case throw a friendly error like “Token not found”).
- Check Jupiter list via getToken(mint):
  - if found: return TokenInfo with verified true, sources ["jupiter"], cached 24h.
- Else run “inflight” dedupe:
  - if inflight has mint, await it.
  - else create promise that:
    1) connection = new Connection(process.env.SOLANA_RPC_URL ?? default)
    2) helius = await fetchHeliusDASAsset(mint) (may be null)
    3) metaplex = await fetchMetaplexMetadata(mint, connection) (only if helius missing symbol/name/logoURI)
    4) decimals = helius.decimals ?? await fetchOnChainDecimals(mint, connection)
    5) build token info and cache it (success TTL 24h)
  - store inflight, finally delete inflight.
- If anything fails, write NEGATIVE cache for 5 minutes to avoid spamming and rethrow a clean error message.

3) Jupiter list fetch hardening inside tokenlist.ts:
- When fetching Jupiter list fails (500), DO NOT throw if disk cache exists.
- Return:
  [...HARDCODED_TOKENS, ...diskCachedTokens]
- Ensure no duplicates by mint (use Map).

4) Update server/swap/index.ts endpoint /api/swap/solana/token/:mint:
- Ensure it returns the FULL TokenInfo returned by resolveToken.
- On error:
  - status 404 for “invalid mint” or “not found”
  - include JSON: { error: "Token lookup failed", details: message }
- Add a tiny per-IP rate limit for this endpoint only (in-memory):
  - max 60 req/min per IP (since UI can spam)
  - if exceeded return 429 with {error:"rate_limited"}

===========================================================
B) CLIENT: token picker + custom mint resolution UX
===========================================================

FILE: client/screens/SwapScreen.tsx (inline modal)
Implement these UX behaviors WITHOUT creating a new component (keep inline, production-ready):

1) When user types/pastes a mint address in the token search field:
- Detect base58-ish strings length 32–44, attempt server lookup:
  GET /api/swap/solana/token/<mint>
- While fetching, show a small “Resolving token…” row.
- On success, show a “CUSTOM TOKEN” card with:
  - logo (if present)
  - symbol + name
  - shortened mint
  - badge:
    - if token.verified true -> “Verified”
    - else -> “Unverified”
  - decimals
- Selecting it should set it as input/output token and close modal.

2) If the token is not verified and has tag pumpfun:
- Show subtle badge “Pump”
- STILL allow selection (we want pump tokens tradable).

3) If server returns 404:
- Show “Token not found” message (don’t keep UNKNOWN forever).
- Keep allowing user to edit.

4) IMPORTANT: debounced lookup:
- Do NOT call server on every keystroke.
- Use 400ms debounce + AbortController to cancel in-flight lookup.

===========================================================
C) CLIENT: quote refresh throttling (stop 1s spam + avoid 429)
===========================================================

Fix the “quotes refresh every second” issue (this causes 429).

In swap quote fetching logic (where you call server quote endpoint):
1) Add state:
- const [liveQuotes, setLiveQuotes] = useState(false); // default false
- const QUOTE_POLL_MS_DEFAULT = 12000; // 12s
- const QUOTE_POLL_MS_LIVE = 2000;     // 2s only if liveQuotes true AND user selected Turbo speed

2) Behavior:
- When user changes amount or token selection:
  - do an immediate quote fetch AFTER 250–400ms debounce
- After that, schedule polling:
  - default every 12s
  - if liveQuotes true AND speed == "Turbo" then 2s
- Use AbortController to cancel previous quote request before starting a new one.
- Ensure only ONE polling timer exists at a time (clearInterval on changes/unmount).
- If server returns 429:
  - backoff: wait 4s then resume at default 12s for 1 minute (do not keep hammering)

3) Add UI toggle in “Advanced” section:
- Label: “Live quotes (more RPC usage)”
- Only enable toggle when Speed == Turbo (otherwise show disabled with helper text “Enable Turbo to use live quotes”)

===========================================================
D) PRODUCTION CHECKS
===========================================================

1) Add environment variables usage notes in server/README or replit.md:
- HELIUS_API_KEY (preferred)
- SOLANA_RPC_URL (already exists)
If HELIUS_API_KEY missing, resolver should still work via Metaplex + on-chain decimals (slower).

2) Make sure nothing breaks build:
- TypeScript types updated
- No Node Buffer usage in client (previous “Buffer doesn’t exist” bug): token resolution is server-side only; client just calls endpoint.

3) Quick tests (write minimal logs):
- Paste a known pumpfun mint ending with “pump” and confirm token shows symbol/name if available.
- SOL->USDC quote works.
- Swap still succeeds.
- No more constant 429 spam when sitting on screen.

DELIVERABLE
- Commit code changes only.
- Do not ask follow-ups.
- After implementation, add a short summary in replit.md: “What changed” + “How to test pump tokens”.

GO IMPLEMENT NOW.