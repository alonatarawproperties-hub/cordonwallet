You are working on Cordon (React Native Expo + server on Replit).
Implement v2a + v2c in one PR: (A) Arbitrum chain support + EVM token discovery, (C) swap pre-flight safety scanner with human-readable warnings.

====================
V2A — ADD ARBITRUM + TOKEN DISCOVERY (EVM)
====================

Context:
- Current EVM balances use viem + hardcoded token list:
  - client/lib/blockchain/tokens.ts (hardcoded tokens per chain)
  - client/lib/blockchain/balances.ts (loops those tokens and calls balanceOf)
- Chains currently: Ethereum(1), Polygon(137), BSC(56), testnets.

Problem:
- User ERC20s on Arbitrum (42161) won't appear because (1) Arbitrum isn't configured, and (2) tokens are hardcoded.

Plan:
1) Add Arbitrum chain config
   - Add Arbitrum One chainId 42161 to your chain registry (wherever you keep supported chains).
   - If you already use viem/chains, import `arbitrum` and use it.
   - Provide an RPC URL via env:
     - EXPO_PUBLIC_ARBITRUM_RPC_URL (client) and/or ARBITRUM_RPC_URL (server)
   - Ensure the app can:
     - fetch native balance
     - fetch ERC20 balances

2) Add token discovery via Moralis (server-proxy to avoid exposing API keys)
   - Create env var: MORALIS_API_KEY (server only)
   - Add server endpoint:
     GET /api/evm/:chainId/:address/tokens
     - Valid chainIds: 1, 56, 137, 42161
     - Map chainId -> Moralis "chain" param:
       1 -> "eth"
       56 -> "bsc"
       137 -> "polygon"
       42161 -> "arbitrum"
     - Call Moralis Wallet Token Balances endpoint (EVM):
       GET https://deep-index.moralis.io/api/v2/:address/erc20?chain=<chain>&exclude_spam=true
       Header: X-API-Key: MORALIS_API_KEY
     - Normalize response into your internal Token model:
       { address, symbol, name, decimals, logoURI?, balanceRaw, balanceFormatted }
     - Apply a simple in-memory cache (per chainId+address) with TTL 30–60s to prevent rate spikes.

   - Client changes:
     - Update client/lib/blockchain/balances.ts:
       Instead of iterating hardcoded tokens, call:
       /api/evm/<chainId>/<walletAddress>/tokens
       Merge results with “featured tokens” ordering if you want (e.g., show USDC/USDT/WETH first).
     - Keep the old hardcoded list only as fallback if API fails.

3) UI expectations:
   - Assets screen should now show:
     - all discovered ERC20s for Ethereum/Polygon/BSC/Arbitrum
     - not just the 5 hardcoded ones
   - Clearly label chain (“Arbitrum”) and show token icon if available (Moralis returns logo sometimes; if null, show fallback).

====================
V2C — SWAP “TOKEN SNIFFER” SAFETY LAYER (EDGE VS RUGCHECKER/TOKENSNIFFER)
====================

Goal:
Before the user swaps SOL/ETH -> token, show a safety panel that is:
- fast (cached)
- human-readable
- honest (what is verified vs unknown)
- actionable (warn/block when needed)

Add a “Token Safety” sheet on SwapScreen:
- Trigger:
  - when a user selects the “YOU RECEIVE” token
  - and also right before executing Swap (refresh scan if older than 60s)
- Display:
  - Overall label: Low / Medium / High Risk
  - “Scanned by Cordon • <relative time>” + a Rescan button

What signals to include (v2c):
A) EVM on-chain checks (verified facts)
- For ERC20 tokens:
  - Is contract verified on explorer? (optional if you can fetch)
  - Basic sanity: has code, not EOA
  - Decimals/symbol exist
- If token is a known proxy pattern, show “Upgradeable: Unknown/Detected” (best-effort)
(Keep this minimal for v2: prioritize speed + correctness)

B) Moralis “Token Security Score” (external signal)
- Add server endpoint:
  GET /api/evm/:chainId/token-security/:tokenAddress
  - Use Moralis Token Security Score endpoint (per docs)
  - Cache TTL 5–10 minutes per token
- Convert returned fields into human-readable warnings:
  - honeypot risk indicators if present
  - trading restrictions if present
  - suspicious deployer / blacklists if present
- If Moralis is down, don’t lie—show “External scan unavailable” (NOT “safe”).

C) Wallet approvals risk (huge practical edge)
- Add server endpoint:
  GET /api/evm/:chainId/:address/approvals
  - Use Moralis Wallet Approvals endpoint (per docs)
  - Return notable approvals:
    - unlimited allowance
    - approvals to known risky spenders (if Moralis flags)
- In Swap “Token Safety” sheet:
  - show “Approvals risk: <none / some>”
  - If user has unlimited approvals to suspicious spender, show warning and link to revoke guidance.

D) UX rules (very important):
- If HIGH risk:
  - show red warning + require a hold-to-confirm (2 seconds)
- If MED risk:
  - show yellow warning + tap “I understand”
- If LOW:
  - show green “Low Risk” but still list what was verified vs external.

Where to place it:
- SwapScreen:
  - Add an info button near “YOU RECEIVE” token selector, and also auto-open sheet on first select of a new token.
- If route is pump.fun:
  - still show safety panel (this is where users need it most)

====================
IMPLEMENTATION NOTES
====================

- Do NOT break existing Solana swap flow. This work is for EVM token discovery + safety overlay usable anywhere swap selects a token (even SOL -> SPL can show the current basic checks).
- Keep all network calls cancellable / debounced in UI.
- Add types:
  - TokenDiscoveryToken
  - TokenSafetyReport { overallRisk, verifiedFacts[], warnings[], unknowns[], sources[] }
- Add tests or at least a simple server route unit test for the chainId->chain mapping and caching.

Deliverables:
1) Arbitrum added to supported EVM chains.
2) Assets screen now shows arbitrary ERC20s via discovery, including on Arbitrum.
3) SwapScreen has Token Safety sheet with:
   - on-chain facts
   - Moralis Token Security Score
   - Moralis Wallet Approvals risk
   - caching + Rescan
   - honest “unknown” handling

After implementation, list the exact files changed and how to configure env vars.

Env vars to document:
- MORALIS_API_KEY (server)
- EXPO_PUBLIC_ARBITRUM_RPC_URL (client, if needed)
- Any existing RPC envs you already use

Proceed now.