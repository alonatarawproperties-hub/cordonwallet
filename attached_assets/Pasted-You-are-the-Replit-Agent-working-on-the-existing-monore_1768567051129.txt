You are the Replit Agent working on the existing monorepo (Expo client + Express server). The swap works but we get noisy “Server responded with 429” logs and occasional degraded UX because we are rate-limited (too many quote/token-list/balance refresh calls). Your job: implement a COMPLETE, production-grade fix in ONE pass.

GOALS
1) Remove/avoid 429 spam while keeping swaps fast.
2) Make quote fetching stable (debounced, cancellable, deduped).
3) Cache token list (TTL) and never refetch repeatedly.
4) Add server-side rate limiting + in-flight dedupe + proper backoff handling for Jupiter.
5) Ensure UI never shows scary red LogBox errors for expected 429/500 token list flukes; show calm UX states.
6) Keep non-custodial: server never sees private keys; only builds tx, client signs.

CONTEXT
- Repo: root package.json, /client Expo RN, /server Express
- Swap already exists and uses Jupiter (quote + swap tx building). Server-assisted approach is currently used (client calls our server, server calls Jupiter).
- Errors seen:
  - 401 Unauthorized before (likely missing/incorrect header or env); now swap succeeded but 429 logs appear.
  - Token list fetch sometimes fails 500 from Jupiter token list endpoint.
- We use paid Helius RPC already. We also want “Turbo/Fast/Standard” speed modes that affect compute budget + priority fee.
- We want pump tokens to work as much as possible; at minimum, don’t break if token list fetch fails—allow manual mint input and fallback lists.

IMPLEMENTATION REQUIREMENTS (DO ALL)
A) CLIENT: Debounce + cancel quote requests
- Find the quote request call site (likely in client/store/swapStore.ts or client/services/swap*).
- Implement a debounced quote fetch (350–600ms; choose 450ms default).
- Use AbortController to cancel any in-flight quote request when a new request begins.
- Do NOT fetch quotes when:
  - amount is 0 or empty
  - pay token or receive token not selected
  - wallet not ready
- Add an “inFlightKey” so if the same params are requested while already fetching, do nothing (client-side dedupe).

B) CLIENT: Token list caching with TTL + fallback
- Find token list module (solanaTokenList.ts).
- Implement:
  - memory cache
  - persistent cache via AsyncStorage
  - TTL default 12 hours
- On app start, load cached token list immediately, render it.
- In background, refresh token list ONLY if TTL expired; if refresh fails (500/timeout), keep cached list silently.
- Add fallback list if no cache exists: include SOL, WSOL, USDC (main), USDT, and a small hardcoded list.
- Add “Manual mint entry” in token selector:
  - user can paste a mint address
  - validate base58 + length
  - fetch metadata via server (or Helius) and add as temporary token item.

C) CLIENT: Balance refresh + post-swap refresh throttling
- After swap success, refresh balances/portfolio ONCE, then stop.
- Add throttling so balances refresh at most once per 10 seconds while user is on Swap screen.
- Ensure UI does not trigger loops.

D) CLIENT: Logging rules (stop scary LogBox spam)
- Add a centralized logger wrapper used by swap/token list.
- If an error is 429 or a known transient (token list 500), log it as DEBUG (console.log) only in dev mode, not console.error.
- Provide user-friendly inline message when quotes are temporarily unavailable:
  - “Network busy, retrying…” without red error banners.
- Remove/reduce any toast that says “Quote failed (401/429)” unless it’s persistent.

E) SERVER: Add rate limit + in-flight dedupe + caching for quote responses
- Find server route handlers for:
  - /api/swap/quote
  - /api/swap/build (or similar)
  - /api/tokenlist
- Add Express middleware rate limit (simple in-memory) per IP + wallet pubkey (if provided):
  - quotes: max 20 requests / 10 seconds per key
  - tokenlist: max 5 / minute per key
- Implement in-flight dedupe:
  - map<cacheKey, Promise<Response>>
  - if request comes in with same cacheKey while promise exists, await it and return same result.
- Implement short-lived caching for quote responses:
  - TTL 2 seconds for quotes (enough to prevent spam)
  - key includes inputMint, outputMint, amount, slippage, mode
- For token list:
  - cache in memory TTL 6 hours server-side too
  - if upstream fails, return cached.

F) SERVER: Proper backoff handling when Jupiter returns 429/5xx
- Wrap upstream fetch calls with:
  - retries: 3
  - exponential backoff with jitter: 300ms, 800ms, 1600ms (+ random 0–200ms)
  - if response has Retry-After header, respect it (cap at 5s).
- If still failing after retries:
  - return a controlled JSON error { code: "UPSTREAM_BUSY", message: "Network busy, try again." } with HTTP 503 (not 500).
- Ensure client treats 503/UPSTREAM_BUSY as “retrying” not as fatal red error.

G) TURBO/FAST/STANDARD handling (priority fees + compute)
- Ensure the swap build route accepts “speedMode” = standard|fast|turbo.
- Map to:
  - priority fee cap (microLamports) or SOL value (choose one consistent)
  - compute unit limit (e.g. 200k / 400k / 800k)
- Add a MAX FEE CAP to protect users:
  - standard: 0.0008 SOL
  - fast: 0.002 SOL
  - turbo: 0.005 SOL
- Include these as ComputeBudgetProgram instructions when building the tx.
- Confirm swap remains non-custodial: server builds tx, client signs.

H) PUMP TOKENS SUPPORT (minimum viable)
- Do NOT hard depend on Jupiter token list.
- If token list fetch fails or token not found, allow manual mint input and try quote anyway.
- If Jupiter cannot route a token (no route), show “No route yet (likely bonding curve).” and do not crash.
- Add a detection hook: if mint is a known pump token and no route, show suggestion “Try after graduation or use Pump swap module (future).” (No need to implement pump program swaps now; just handle gracefully.)

I) SECURITY: Don’t block legit swaps due to decoder/drainer logic
- The previous “Blocked: Failed to decode transaction: Property ‘Buffer’ doesn’t exist” indicates the decoder was trying to use Node Buffer in RN.
- Fix: ensure any decoder logic uses Uint8Array and avoids Buffer; or add a safe Buffer polyfill for RN only if needed.
- Also: Ensure drainer detection does NOT falsely block Jupiter swap transactions. If drainer detection runs on swap tx, whitelist Jupiter swap patterns:
  - allow SetAuthority ONLY if it targets WSOL temporary ATA close authority patterns OR matches known Jupiter aggregator behavior.
  - If uncertain, show a “Review transaction” warning instead of blocking for swaps initiated from our Swap screen.
- Add a parameter to decoder: decodeSolanaTransaction(txBase64, userPubkey, context)
  - context = "swap"|"dapp"
  - For context="swap", do NOT hard-block on Assign/SetAuthority unless the authority change targets the user’s main system account or attempts permanent authority transfer to unknown address.
  - For context="dapp", keep strict blocking.
- Implement this cleanly and update call sites that have wallet pubkey:
  - WalletConnectHandler.tsx
  - SignRequestSheet.tsx
  - BrowserWebViewScreen.tsx
  - Swap screen flow should pass context="swap".

DELIVERABLES
1) Implement all changes in code with clean types and comments.
2) Ensure app builds and swap still works.
3) Add a short DEV note in replit.md: “How to test swap + what 429 means + how retry/backoff works.”
4) Provide a quick checklist for manual QA:
   - typing amount quickly does not spam network
   - token list loads instantly from cache
   - quotes recover automatically under rate limit
   - swap succeeds in Standard/Fast/Turbo
   - no red LogBox spam for 429/500
   - manual mint works

DO NOT ASK ME QUESTIONS. Just implement based on repo structure and existing files. If you must choose defaults, choose the safest UX defaults (debounce 450ms, quote TTL 2s, token list TTL 12h, server backoff as specified).

After implementing, run:
- npm run check:types
- npm run lint (if it exists)
and fix any errors.

Start now.